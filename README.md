# ESP32 Telemetry System

A prototype embedded system exploring real-time sensor monitoring, state machine design, and anomaly detection in networked devices

## Overview

This project explores how a ESP32-based embedded device behaves in a real connected environment. The focus is on telemetry, reliability, and system behavior when sensor data is transmitted over a network.

An ESP32 reads sensor data and publishes it via MQTT to a Python backend, which logs incoming telemetry and monitors device state. The system is used to observe real-world constraints such as unreliable connectivity, imperfect timing, missing data and abnormal readings and also to understand how the system reacts when these conditions occur.

## Architecture

The system is structured as a telemetry pipeline with clear separation of responsibilities between components.

**Data flow:**

Sensor → ESP32 (C++) → MQTT broker → Python backend → logs and monitoring

### Components

**ESP32 (Firmware - C++)**
- Reads data from a sensor
- Controls sampling timing
- Publishes telemetry messages over MQTT
- Handles basic reliability concerns such as reconnection and invalid readings

**MQTT Broker**
- Acts as the message transport layer between devices and backend
- Decouples embedded firmware from backend processing
- Allows the system to scale to multiple devices without direct coupling

**Backend (Python)**
- Subscribes to MQTT topics and receives telemetry data
- Logs incoming measurements to persistent storage
- Monitors device activity (online/offline detection)
- Performs data analysis and anomaly detection

This separation allows each part of the system to evolve independently and makes it easier to reason about system behavior, failure modes and timing issues in a real connected environment.

## Device State Machine
The ESP32 firmware implements an explicit state machine to model device behavior and failure handling

### States
- **INIT**
  - Initial boot state
  - Hardware and network initialization
  - Visualized by a blue LED
  - Transitions to: RUNNING

- **RUNNING**
  - Normal operation
  - Sensor sampling and MQTT publishing active
  - Visualized by a green LED
  - Transitions to: ERROR if MQTT unavailable for > 20 seconds

- **RUNNING (MQTT degraded)**
  - Device is operational but MQTT connectivity is temporarily unavailable
  - Visualized by a white LED
  - A timeout is started to track prolonged outages
  - Transitions to: ERROR (timeout) or back to normal RUNNING (reconnect)

- **ERROR**
  - MQTT connectivity has been unavailable for longer than a defined threshold
  - Device enters a error state
  - Visualized by a red LED
  - Automatic recovery is attempted when connectivity is restored
  - Transitions to: RUNNING when connectivity restored

## Key Features

**Embedded Device (ESP32)**
- Sensor data acquisition using C++ firmware
- Configurable sampling intervals and periodic publishing
- Explicit device state machine (INIT/RUNNING/ERROR)
- LED-based visual feedback for device state and connectivity
- Automatic Wi-Fi and MQTT reconnection logic 
- Structured MQTT payloads with device identification

**Backend & Monitoring**
- Python backend subscribing to MQTT telemetry
- Persistent logging of sensor data to JSONL files
- Real time device state monitoring (online/offline detection)
- Anomaly detection: out-of-range values, sudden changes, missing messages
- Live terminal dashboard for observing system behavior

## Telemetry Format

Telemetry is published over MQTT using structured topics and an explicit payload format.

### MQTT Topic
```iot/home/{sensor_id}/telemetry```
where `{sensor_id}` identifies the device (e.g. `A01`, `B01`)

### ESP32 Payload
```json
{
  "isReadingsValid": true,
  "hasNewReading": true,
  "sampledAt": 14835025,
  "publishedAt": 14835025,
  "ageReadings": 14835025,
  "temperatureCelcius": 23.9,
  "temperatureFahrenheit": 75.02,
  "humidityPercent": 6.0,
  "heatIndexCelcius": 22.5,
  "heatIndexFahrenheit": 72.5,
}
```
- `isReadingsValid`  
  Flag produced by the firmware indicating whether the sensor reading is considered valid

- `hasNewReading`  
  Indicates whether the published telemetry contains a new sampled sensor reading

- `sampledAt`  
  Timestamp (milliseconds since device boot) indicating when the reading was sampled   

- `publishedAt`  
  Timestamp (milliseconds since device boot) indicating when the telemetry message was published 

- `ageReadings`  
  Age of the sensor reading at publish time (in milliseconds) 

### Backend Log record

```json
{
  "sensor_id": "A01",
  "temperatureCelcius": 23.9,
  "temperatureFahrenheit": 75.02,
  "humidityPercent": 6.0,
  "heatIndexCelcius": 22.5,
  "heatIndexFahrenheit": 72.5,
  "sampledAt": 14835025,
  "received_at": 1766807441.159206,
  "topic": "iot/home/A01/telemetry"
}
```
- `sensor_id` : Unique identifier of the ESP32 device. Derived from MQTT topic
- `sampledAt` : Timestamp (in milliseconds since device boot) generated by the ESP32 device
- `received_at` : Timestamp (in seconds (UTC)) recorded by the backend when the MQTT message is received
- `topic`: Full MQTT topic path 

## How to Run

### Prerequisites

- ESP32 development board with DHT11/DHT22 temperature/humidity sensor
- Python 3.x
- MQTT broker (HiveMQ Cloud or local Mosquitto)
- Arduino IDE

---

### 1. Configure and Flash ESP32 Firmware

1. Open the firmware code in Arduino IDE or PlatformIO
2. Create a `secrets.h` file with your credentials:
```cpp
   #define WIFI_SSID "your_wifi_ssid"
   #define WIFI_PWD "your_wifi_password"
   #define MQTT_USERNAME "your_mqtt_username"
   #define MQTT_PWD "your_mqtt_password"
```
3. Connect the ESP32 via USB and flash the firmware
4. Open the serial monitor to verify:
   - Wi-Fi connection established
   - MQTT broker connection successful
   - Sensor data publishing periodically

---

### 2. Set Up Python Backend

1. (Optional) Create and activate a virtual environment
2. Install dependencies:
```bash
   pip install paho-mqtt rich
```
3. Create a `config.py` file with your MQTT credentials:
```python
   MQTT_BROKER = "your_broker_address"
   MQTT_PORT = 8883
   MQTT_USERNAME = "your_username"
   MQTT_PASSWORD = "your_password"
```

---

### 3. Run the Backend Subscriber

Start the subscriber to begin collecting telemetry:
```bash
python subscriber_script.py
```

Incoming telemetry will be:
- Printed to the console
- Logged to `data.jsonl`
- Monitored for device online/offline status

---

### 4. Observe System Behavior

- Verify that telemetry messages are being received and logged
- Disconnect the ESP32 or network to observe offline detection
- Reconnect the device to observe automatic recovery

---

## Monitoring and Analysis Tools

### Live Dashboard
View real-time device status, statistics, and anomalies:
```bash
python dashboard.py
```

### Offline Analysis
Analyze logged telemetry data from `data.jsonl`:
```bash
python telemetry_analyzer.py
```

Provides:
- Statistical analysis (mean, min, max, median)
- Missing message detection
- Out-of-range value detection
- Sudden change detection

## Design Decisions

Several design choices were made intentionally to keep the system focused on reliability, observability, and clarity of behavior.

- **Reliability over UI polish**  
  The project prioritizes correct data flow, fault detection, and recovery behavior rather than user interface design. Visualization is treated as a supporting tool.

- **Rule-based anomaly detection**  
  Anomalies are detected using simple, explicit rules (out-of-range values, sudden changes, missing messages) instead of machine learning. This keeps the system explainable and suitable for inspecting real telemetry behavior.

- **Backend-driven logic**  
  Device state, anomaly detection, and offline detection are handled in the backend. The dashboard only visualizes existing backend state and does not contain decision logic.

- **Append-only JSONL logging**  
  Telemetry is logged using an append-only JSONL format for robustness and simplicity. This allows safe inspection of historical data and offline analysis without requiring a database and easy integration with analysis scripts.

## Limitations

**Timing and jitter analysis**
- Device and backend timestamps are recorded but analysis of timing drift and jitter could be added to better characterize real-time behavior.

**Power optimization** 
- Power consumption is not optimized in the current implementation. Publish intervals and sleep modes could be explored.

**System robustness:**
- Message delivery guarantees rely entirely on MQTT QoS settings without application-level verification

**Firmware architecture:**
- The firmware runs without an RTOS, which limits separation of concerns between sampling, communication, and monitoring
- Error recovery is basic - more sophisticated fault handling could be added

## Demo
***Demo coming soon***